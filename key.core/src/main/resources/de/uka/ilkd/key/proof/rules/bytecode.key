\functions {
    // Heap putfieldNative(java.lang.Object,Seq);

}

\schemaVariables {
    \modalOperator {diamond, box, diamond_transaction, box_transaction} #allmodal;
    \modalOperator {diamond, diamond_transaction} #diamond;
    \modalOperator {box, box_transaction} #box;

    \formula post, inv, post1;
    \program Type #t, #t2;
    \program NonPrimitiveType #npit;
    \program PrimitiveType #pit;

    \term G q;
    \skolemTerm G sk;

    \program ArrayLength #length;

    \program MultipleVariableDeclaration #multvardecl;
    \program ArrayPostDeclaration #arraypost;
    \program SimpleExpression #se, #se0, #se1, #se2;
    \program SimpleExpression #src, #dest, #srcOff, #destOff, #arlength;
    \program SimpleExpressionNonFloatDouble #senf, #senf0, #senf1;

    \program LeftHandSide #lhs, #lhs0, #lhs1, #lhs2;
    \program LeftHandSide #attribute;
    \program Variable #loc;
    \program StaticVariable #sv, #sv0, #sv1;

    \program Variable #v, #v0, #v1, #v2, #boolv, #a, #a0, #a1, #a2, #a3;

    \program ConstantPrimitiveTypeVariable #cv; // variables that are compile-time constants
    \program Variable #b0, #ar1;
    \program VariableInitializer #vi;
    \program SimpleJavaBooleanExpression #seBool, #seBool0, #seBool1, #seBool2;
    \program JavaBooleanExpression #exBool, #exBool0, #exBool1, #exBool2;

    \program NonSimpleExpression #nseBool, #nseBool0, #nseBool1, #nseBool2;
    \program Statement #s, #s0, #s1;
    \program LoopInit #loopInit;
    \program Guard #guard;
    \program ForUpdates #forupdates;
    \program ForLoop #forloop;
    \program Expression #e, #e0, #e1, #e2;
    \program NonSimpleExpression #nse, #nse0, #nse1, #nse2, #nv;
    \program NonSimpleExpressionNoClassReference #nsencr;

    \program ClassReference #cr;

    \program [list] Statement #slist, #slist1, #slist2, #slist3;
    \program [list] Expression #elist;
    \program [list] SimpleExpression #selist;
    \program [list] Catch #cs;

    \program Switch #sw;
    \program Label #lb, #lb0, #lb1, #innerLabel, #outerLabel;
    \program NonSimpleMethodReference #nsmr;
    \program NonModelMethodBody #mb;
    \program MethodName #mn;

    \program NonPrimitiveType [name = javacard.framework.JCSystem] #jcsystemType;
    \program MethodName [name = nativeKeYBeginTransaction] #beginTransaction;
    \program MethodName [name = nativeKeYCommitTransaction] #commitTransaction;
    \program MethodName [name = nativeKeYAbortTransaction] #abortTransaction;

    \program ExecutionContext #ex, #ex1;
    \program ProgramMethod #pm;

    \formula anon1, anon2, anon3;

    \formula for1, for2;

    \program NonStringLiteral #lit;
    \program StringLiteral #slit;

    \variables int iv, iv2, iv3;
    \term int idx;

    // generic sorts
    \term G variant;
    \term GOS array;
    \term H obj;

    \variables G x;
    \term H then, else;

    \term G updatedTerm1, updatedTerm2;
}
\rules {


    bytecodePutfield {
        \schemaVar \program MethodName [name = putfield] #putfield;
        \schemaVar \program NonPrimitiveType [name = de.aload.JVM] #jvmType;
        \schemaVar \program Variable #heapPoppedStack;
        \schemaVar \program Variable #opStack;
        \find(\modality{#allmodal}{.. #v.#putfield(#slit); ...}\endmodality (post))
        \varcond(
            \isContent [set_to_parameter, full, de_aload_JVM_opStack](#slit, #a),
            \isContent [full](#slit, #a1),
            \new(#heapPoppedStack, Heap),
            \new(#opStack, Seq)
        )
        \replacewith(
        {#opStack := 
                Seq::select(
                    heap,
                    #v,
                    #memberPVToField(#a)
                )}
        {#heapPoppedStack := store(
                heap,
               #v,
                #memberPVToField(#a),
                seqSub(#opStack,
                    0,
                    seqLen(#opStack)-2
                )
                
            )}
         {heap := store(
            #heapPoppedStack,
            Object::seqGet(
                #opStack,
                seqLen(#opStack)-2),
            #memberPVToField(#a1),
            any::seqGet(
                #opStack,
                seqLen(#opStack)-1)
            )}\modality{#allmodal}{..  ...}\endmodality (post))
        \displayname "putfield bytecode"
    };

    bytecodeGetfield {
        \schemaVar \program MethodName [name = getfield] #getfield;
        \find(\modality{#allmodal}{.. #v.#getfield(#slit); ...}\endmodality (post))
        \varcond(
            \isContent [set_to_parameter, full, de_aload_JVM_opStack](#slit, #a),
            \isContent [full](#slit, #a1),
            \new(#a2, Seq)
        )
        \replacewith(
         {heap := store(
            heap,   
            #v,
            #memberPVToField(#a),
            seqConcat(
                Seq::select(
                    heap,
                    #v,
                    #memberPVToField(#a)
                ),
                seqSingleton(
                    any::select(
                        heap,
                        Object::seqGet(
                            Seq::select(
                                heap,
                                #v,
                                #memberPVToField(#a)
                            ),
                            seqLen(
                                Seq::select(
                                    heap,
                                    #v,
                                    #memberPVToField(#a)
                                )
                            )-1
                        ),
                        #memberPVToField(#a1)
                    )
                )
            )
         )
            }\modality{#allmodal}{..  ...}\endmodality (post))
        \displayname "getfield bytecode"
    };

    bytecodeNew {
        \schemaVar \program MethodName [name = newi] #newi;
        \find(\modality{#allmodal}{.. #v.#newi(#slit); ...}\endmodality (post))
        \replacewith(\modality{#allmodal}{.. #bytecode-new(#slit); ...}\endmodality (post))
        \displayname "new bytecode"
    };

    bytecodebastore {
        \schemaVar \program MethodName [name = bastore] #bastore;
        \schemaVar \program Variable #heapPoppedStack;
        \schemaVar \program Variable #opStack;
        \schemaVar \program Variable #opStackLength;
        \schemaVar \program Variable #newvalue;
        \schemaVar \program Variable #index;
        \schemaVar \program Variable #array;

        \find(\modality{#allmodal}{.. #v.#bastore(); ...}\endmodality (post))
        \varcond(
            \isContent [set_to_parameter, full, de_jvm_JVM_opStack](#slit, #a),
            \new(#heapPoppedStack, Heap),
            \new(#opStack, Seq),
            \new(#opStackLength, int),
            \new(#newvalue, byte),
            \new(#index, int),
            \new(#array, Object)
       )
        \replacewith(
        {#opStack := 
                Seq::select(
                    heap,
                    #v,
                    #memberPVToField(#a)
                )}
        {#opStackLength := 
            seqLen(#opStack)
        } 
        {#heapPoppedStack := store(
                heap,
               #v,
                #memberPVToField(#a),
                seqSub(#opStack,
                    0,
                    seqLen(#opStack)-3
                )
                
            )}
        {#newvalue := byte::seqGet(#opStack, #opStackLength-1)}
        {#index := int::seqGet(#opStack, #opStackLength-2)}
        {#array := Object::seqGet(#opStack, #opStackLength-3)}
        {heap := store(#heapPoppedStack, #array, arr(#index), #newvalue)}
        \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "bastore bytecode"

    };

    bytecodesastore {
        \schemaVar \program MethodName [name = sastore] #sastore;
        \schemaVar \program Variable #heapPoppedStack;
        \schemaVar \program Variable #opStack;
        \schemaVar \program Variable #opStackLength;
        \schemaVar \program Variable #newvalue;
        \schemaVar \program Variable #index;
        \schemaVar \program Variable #array;

        \find(\modality{#allmodal}{.. #v.#sastore(); ...}\endmodality (post))
        \varcond(
            \isContent [set_to_parameter, full, de_jvm_JVM_opStack](#slit, #a),
            \new(#heapPoppedStack, Heap),
            \new(#opStack, Seq),
            \new(#opStackLength, int),
            \new(#newvalue, short),
            \new(#index, int),
            \new(#array, Object)
       )
        \replacewith(
        {#opStack := 
                Seq::select(
                    heap,
                    #v,
                    #memberPVToField(#a)
                )}
        {#opStackLength := 
            seqLen(#opStack)
        } 
        {#heapPoppedStack := store(
                heap,
               #v,
                #memberPVToField(#a),
                seqSub(#opStack,
                    0,
                    seqLen(#opStack)-3
                )
                
            )}
        {#newvalue := short::seqGet(#opStack, #opStackLength-1)}
        {#index := int::seqGet(#opStack, #opStackLength-2)}
        {#array := Object::seqGet(#opStack, #opStackLength-3)}
        {heap := store(#heapPoppedStack, #array, arr(#index), #newvalue)}
        \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "bastore bytecode"

    };
}

\rules {
    bytecodeiastore {
        \schemaVar \program MethodName [name = iastore] #iastore;
        \schemaVar \program Variable #heapPoppedStack;
        \schemaVar \program Variable #opStack;
        \schemaVar \program Variable #opStackLength;
        \schemaVar \program Variable #newvalue;
        \schemaVar \program Variable #index;
        \schemaVar \program Variable #array;

        \find(\modality{#allmodal}{.. #v.#iastore(); ...}\endmodality (post))
        \varcond(
            \isContent [set_to_parameter, full, de_jvm_JVM_opStack](#slit, #a),
            \new(#heapPoppedStack, Heap),
            \new(#opStack, Seq),
            \new(#opStackLength, int),
            \new(#newvalue, int),
            \new(#index, int),
            \new(#array, Object)
       )
        \replacewith(
        {#opStack := 
                Seq::select(
                    heap,
                    #v,
                    #memberPVToField(#a)
                )}
        {#opStackLength := 
            seqLen(#opStack)
        } 
        {#heapPoppedStack := store(
                heap,
               #v,
                #memberPVToField(#a),
                seqSub(#opStack,
                    0,
                    seqLen(#opStack)-3
                )
                
            )}
        {#newvalue := int::seqGet(#opStack, #opStackLength-1)}
        {#index := int::seqGet(#opStack, #opStackLength-2)}
        {#array := Object::seqGet(#opStack, #opStackLength-3)}
        {heap := store(#heapPoppedStack, #array, arr(#index), #newvalue)}
        \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "iastore bytecode"

    };
}

\rules {

    bytecodelastore {
        \schemaVar \program MethodName [name = lastore] #lastore;
        \schemaVar \program Variable #heapPoppedStack;
        \schemaVar \program Variable #opStack;
        \schemaVar \program Variable #opStackLength;
        \schemaVar \program Variable #newvalue;
        \schemaVar \program Variable #index;
        \schemaVar \program Variable #array;

        \find(\modality{#allmodal}{.. #v.#lastore(); ...}\endmodality (post))
        \varcond(
            \isContent [set_to_parameter, full, de_jvm_JVM_opStack](#slit, #a),
            \new(#heapPoppedStack, Heap),
            \new(#opStack, Seq),
            \new(#opStackLength, int),
            \new(#newvalue, long),
            \new(#index, int),
            \new(#array, Object)
       )
        \replacewith(
        {#opStack := 
                Seq::select(
                    heap,
                    #v,
                    #memberPVToField(#a)
                )}
        {#opStackLength := 
            seqLen(#opStack)
        } 
        {#heapPoppedStack := store(
                heap,
               #v,
                #memberPVToField(#a),
                seqSub(#opStack,
                    0,
                    seqLen(#opStack)-3
                )
                
            )}
        {#newvalue := long::seqGet(#opStack, #opStackLength-1)}
        {#index := int::seqGet(#opStack, #opStackLength-2)}
        {#array := Object::seqGet(#opStack, #opStackLength-3)}
        {heap := store(#heapPoppedStack, #array, arr(#index), #newvalue)}
        \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "iastore bytecode"

    };

    bytecodefastore {
        \schemaVar \program MethodName [name = fastore] #fastore;
        \schemaVar \program Variable #heapPoppedStack;
        \schemaVar \program Variable #opStack;
        \schemaVar \program Variable #opStackLength;
        \schemaVar \program Variable #newvalue;
        \schemaVar \program Variable #index;
        \schemaVar \program Variable #array;

        \find(\modality{#allmodal}{.. #v.#fastore(); ...}\endmodality (post))
        \varcond(
            \isContent [set_to_parameter, full, de_jvm_JVM_opStack](#slit, #a),
            \new(#heapPoppedStack, Heap),
            \new(#opStack, Seq),
            \new(#opStackLength, int),
            \new(#newvalue, float),
            \new(#index, int),
            \new(#array, Object)
       )
        \replacewith(
        {#opStack := 
                Seq::select(
                    heap,
                    #v,
                    #memberPVToField(#a)
                )}
        {#opStackLength := 
            seqLen(#opStack)
        } 
        {#heapPoppedStack := store(
                heap,
               #v,
                #memberPVToField(#a),
                seqSub(#opStack,
                    0,
                    seqLen(#opStack)-3
                )
                
            )}
        {#newvalue := float::seqGet(#opStack, #opStackLength-1)}
        {#index := int::seqGet(#opStack, #opStackLength-2)}
        {#array := Object::seqGet(#opStack, #opStackLength-3)}
        {heap := store(#heapPoppedStack, #array, arr(#index), #newvalue)}
        \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "fastore bytecode"

    };
    bytecodedastore {
        \schemaVar \program MethodName [name = dastore] #dastore;
        \schemaVar \program Variable #heapPoppedStack;
        \schemaVar \program Variable #opStack;
        \schemaVar \program Variable #opStackLength;
        \schemaVar \program Variable #newvalue;
        \schemaVar \program Variable #index;
        \schemaVar \program Variable #array;

        \find(\modality{#allmodal}{.. #v.#dastore(); ...}\endmodality (post))
        \varcond(
            \isContent [set_to_parameter, full, de_jvm_JVM_opStack](#slit, #a),
            \new(#heapPoppedStack, Heap),
            \new(#opStack, Seq),
            \new(#opStackLength, int),
            \new(#newvalue, double),
            \new(#index, int),
            \new(#array, Object)
       )
        \replacewith(
        {#opStack := 
                Seq::select(
                    heap,
                    #v,
                    #memberPVToField(#a)
                )}
        {#opStackLength := 
            seqLen(#opStack)
        } 
        {#heapPoppedStack := store(
                heap,
               #v,
                #memberPVToField(#a),
                seqSub(#opStack,
                    0,
                    seqLen(#opStack)-3
                )
                
            )}
        {#newvalue := double::seqGet(#opStack, #opStackLength-1)}
        {#index := int::seqGet(#opStack, #opStackLength-2)}
        {#array := Object::seqGet(#opStack, #opStackLength-3)}
        {heap := store(#heapPoppedStack, #array, arr(#index), #newvalue)}
        \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "dastore bytecode"

    };


    bytecodecastore {
        \schemaVar \program MethodName [name = castore] #castore;
        \schemaVar \program Variable #heapPoppedStack;
        \schemaVar \program Variable #opStack;
        \schemaVar \program Variable #opStackLength;
        \schemaVar \program Variable #newvalue;
        \schemaVar \program Variable #index;
        \schemaVar \program Variable #array;

        \find(\modality{#allmodal}{.. #v.#castore(); ...}\endmodality (post))
        \varcond(
            \isContent [set_to_parameter, full, de_jvm_JVM_opStack](#slit, #a),
            \new(#heapPoppedStack, Heap),
            \new(#opStack, Seq),
            \new(#opStackLength, int),
            \new(#newvalue, char),
            \new(#index, int),
            \new(#array, Object)
       )
        \replacewith(
        {#opStack := 
                Seq::select(
                    heap,
                    #v,
                    #memberPVToField(#a)
                )}
        {#opStackLength := 
            seqLen(#opStack)
        } 
        {#heapPoppedStack := store(
                heap,
               #v,
                #memberPVToField(#a),
                seqSub(#opStack,
                    0,
                    seqLen(#opStack)-3
                )
                
            )}
        {#newvalue := char::seqGet(#opStack, #opStackLength-1)}
        {#index := int::seqGet(#opStack, #opStackLength-2)}
        {#array := Object::seqGet(#opStack, #opStackLength-3)}
        {heap := store(#heapPoppedStack, #array, arr(#index), #newvalue)}
        \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "castore bytecode"

    };


    bytecodeaastore {
        \schemaVar \program MethodName [name = aastore] #aastore;
        \schemaVar \program Variable #heapPoppedStack;
        \schemaVar \program Variable #opStack;
        \schemaVar \program Variable #opStackLength;
        \schemaVar \program Variable #newvalue;
        \schemaVar \program Variable #index;
        \schemaVar \program Variable #array;

        \find(\modality{#allmodal}{.. #v.#aastore(); ...}\endmodality (post))
        \varcond(
            \isContent [set_to_parameter, full, de_jvm_JVM_opStack](#slit, #a),
            \new(#heapPoppedStack, Heap),
            \new(#opStack, Seq),
            \new(#opStackLength, int),
            \new(#newvalue, Object),
            \new(#index, int),
            \new(#array, Object)
       )
        \replacewith(
        {#opStack := 
                Seq::select(
                    heap,
                    #v,
                    #memberPVToField(#a)
                )}
        {#opStackLength := 
            seqLen(#opStack)
        } 
        {#heapPoppedStack := store(
                heap,
               #v,
                #memberPVToField(#a),
                seqSub(#opStack,
                    0,
                    seqLen(#opStack)-3
                )
                
            )}
        {#newvalue := Object::seqGet(#opStack, #opStackLength-1)}
        {#index := int::seqGet(#opStack, #opStackLength-2)}
        {#array := Object::seqGet(#opStack, #opStackLength-3)}
        {heap := store(#heapPoppedStack, #array, arr(#index), #newvalue)}
        \modality{#allmodal}{..  ...}\endmodality (post))
        \heuristics(method_expand)
        \displayname "aastore bytecode"

    };

    
}



